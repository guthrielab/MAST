import pandas as pd
import sys
import os
from Bio import SeqIO
from docx import Document
from jinja2 import Template


#Declaring inputs
input_file = sys.argv[1]
output_base_name = sys.argv[2]
fasta_file = sys.argv[4]
resistances = {}

df = pd.read_csv(input_file, sep='\t')
df_mutations = pd.read_csv('~/MAST/MAST/Data/all_resistant_variants.csv')
df_lineage = pd.read_csv('~/MAST/MAST/Data/Lineage.csv')



def find_matching_range(row, ranges):
    matching_row = ranges[
        (ranges['position'] == row['POS']) & 
        (ranges['reference_nucleotide'] == row['REF']) &
        (ranges['alternative_nucleotide'] == row['ALT'])
    ]
    return matching_row if not matching_row.empty else None


for _, pos_row in df.iterrows():
    match = find_matching_range(pos_row, df_mutations)
    if match is not None:
        for _, range_row in match.iterrows():
            variant = range_row['variant']
            drug = range_row['drug']
            resistances[variant] = drug 

for _, pos_row in df.iterrows():
    match = find_matching_range(pos_row, df_lineage)
    if match is not None:
        for _, range_row in match.iterrows():
            lineage = range_row['LIN']
            resistances['Lineage'] = lineage 




#This Part of the code is for the special considerations

sequences = []

for record in SeqIO.parse(fasta_file, "fasta"):
    sequences.append(str(record.seq))
    
sequence = sequences[0]


def get_complement(sequence):
    """
    Takes the complement of a sequence. Important because the gene analyzed in this part of the program
    are translated in the opposit way of how the sequence is written in the fasta
    
    sequence: nucleotide sequence generated by get_mutated_sequence()
    """
    
    # Dictionary mapping each nucleotide to its complement
    complement = {
        'A': 'T',
        'T': 'A',
        'C': 'G',
        'G': 'C'
    }
    
    # Generate the complement sequence
    complement_sequence = ''.join(complement.get(nucleotide, nucleotide) for nucleotide in sequence)
    
    return complement_sequence



def translate_gene_sequence(sequence):
    """
    This function generates the amino acid sequence of a sequence based on its nucleotide sequence. 
    If the sequence is enetered as True, then an indel was detected in the get_mutated_sequence function.
    This will return "indel". Similarly, if no start codon is found, the gene will not be translated and
    it will be treated as an indel (Resistance will be present)
    
    sequence: nucleotide sequence generated by get_mutated_sequence()
    """
    
    
    
    # Declaring important codons and amino acid list
    start_codon = ['TAC', 'GTG', 'AAC', 'TTG', 'ATG']
    amino_acids = []
    
    
    # Declaring codons
    amino_acids_to_codons = {
    'A': ['GCT', 'GCC', 'GCA', 'GCG'],          # Alanine
    'C': ['TGT', 'TGC'],                        # Cysteine
    'D': ['GAT', 'GAC'],                        # Aspartic Acid
    'E': ['GAA', 'GAG'],                        # Glutamic Acid
    'F': ['TTT', 'TTC'],                        # Phenylalanine
    'G': ['GGT', 'GGC', 'GGA', 'GGG'],          # Glycine
    'H': ['CAT', 'CAC'],                        # Histidine
    'I': ['ATT', 'ATC', 'ATA'],                 # Isoleucine
    'K': ['AAA', 'AAG'],                        # Lysine
    'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'],  # Leucine
    'M': ['ATG'],                               # Methionine
    'N': ['AAT', 'AAC'],                        # Asparagine
    'P': ['CCT', 'CCC', 'CCA', 'CCG'],          # Proline
    'Q': ['CAA', 'CAG'],                        # Glutamine
    'R': ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'],  # Arginine
    'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'],  # Serine
    'T': ['ACT', 'ACC', 'ACA', 'ACG'],          # Threonine
    'V': ['GTT', 'GTC', 'GTA', 'GTG'],          # Valine
    'W': ['TGG'],                               # Tryptophan
    'Y': ['TAT', 'TAC'],                        # Tyrosine
    '*': ['TAA', 'TAG', 'TGA'] }

    #Rearranges dictionaries keys and valeus
    codons_to_amino_acids = {codon: aa for aa, codons in amino_acids_to_codons.items() for codon in codons}
    
    #checks if the mutation is an indel
    if sequence == True:
        return 'indel'


    
    # Find the start codon
    start_index = None
    for i in range(0, len(sequence) - 2, 3):
        if sequence[i:i+3].upper() in start_codon:
            start_index = i
            break
    
    if start_index is None:
        return 'indel'
    
    # Translate the sequence from the start codon
    for i in range(start_index, len(sequence) - 2, 3):
        codon = sequence[i:i+3].upper()
        amino_acid = codons_to_amino_acids.get(codon, '?')  # Use '?' for unknown codons
        amino_acids.append(amino_acid)
    
    # Returns the amino acid sequence
    return ''.join(amino_acids) 



def get_mutated_sequence(df, positions, sequence):
    
    """
    This function takes a data frame and applies mutations to a template of the gene. If an indel is detected 
    it returns True
    
    df: Data frame of mutations
    positions: the coordinates of the gene
    sequence: reference sequence (HRv37)
    """
    
    
    # Filters mutations to only include the ones in the gene
    df_gene = df[(df['POS'] >= positions[0]) & (df['POS'] <= positions[1])]
    
    
    for i, row in df_gene.iterrows():
        
        #Checks if its an indel
        if 'del' in row['INFO'] or 'ins' in row['INFO']:
            return True
        
        # Checks information of mutation
        ref = row['REF']
        alt = row['ALT']
        pos = int(row['POS']) - 1
        
        # Applies mutation
        sequence = sequence[:pos] + alt + sequence[(pos) + len(alt):]


    # Returns the sequence, but only at the coordinates of the gene
    return sequence[positions[0]:positions[1]]


katG= get_mutated_sequence(df, [2153888,2156111], sequence)
if katG != True:
    katG = get_complement(katG[::-1])


ethA = get_mutated_sequence(df, [4326003,4327473], sequence)
if ethA != True:
    ethA = get_complement(ethA[::-1])


gid = get_mutated_sequence(df, [4407527,4408202], sequence)
if gid != True:
    gid = get_complement(gid[::-1])


pncA = get_mutated_sequence(df, [2288680,2289241], sequence)
if pncA != True:
    pncA = get_complement(pncA[::-1])
    
    
rpoB = get_mutated_sequence(df, [759806,763325], sequence)


print(pncA)

gene_dict = {'katG': katG, 
             'ethA': ethA, 
             'gid': gid,
             'pncA' : pncA,
             'rpoB' : rpoB}

genes = {'katG': 'Isoniazid',
      'ethA': 'Ethionamide',
      'gid': 'Streptomycin',
      'pncA': 'Pyrazinamide',
      'rpoB' : 'Rifampicin'
     }

for key, value in gene_dict.items():
    
    amino_sequence = translate_gene_sequence(value)
    
    if key == 'rpoB':
        print(translate_gene_sequence(sequence[759806:763325]))
        print(amino_sequence)
        if amino_sequence != translate_gene_sequence(sequence[759806:763325]):
            resistances[key] = genes[key]
        elif amino_sequence == 'indel':
            resistances[key] = genes[key]
        
    else:
        if amino_sequence.count('*') > 1:
            resistances[key] = genes[key]
        elif amino_sequence == 'indel':
            resistances[key] = genes[key]


template_path = os.path.expanduser('~/MAST/MAST/Data/Report_Template.docx')
doc = Document(template_path)
patient_info_path = "~/MAST/MAST/Data/patient_info.csv"
output_dir = sys.argv[3]


#Making the document
os.makedirs(output_dir, exist_ok=True)
doc = Document(template_path)

target_barcode = output_base_name
df = pd.read_csv(patient_info_path)

row = df[df['Barcode'] == target_barcode]

if row.empty:
    print(f"No record found with Barcode: {target_barcode}")
    exit(1)

patient_info = row.to_dict(orient='records')[0]

genes = {
    'Ethambutol': 'Resistant', 'Ethambutol_g': 'None',
    'Pyrazinamide': 'Resistant', 'Pyrazinamide_g': 'None',
    'Isoniazid': 'Resistant', 'Isoniazid_g': 'None',
    'Rifampin': 'Resistant', 'Rifampin_g': 'None',
    'Streptomycin': 'Resistant', 'Streptomycin_g': 'None',
    'Ciprofloxacin': 'Resistant', 'Ciprofloxacin_g': 'None',
    'Ofloxacin': 'Resistant', 'Ofloxacin_g': 'None',
    'Moxifloxacin': 'Resistant', 'Moxifloxacin_g': 'None',
    'Amikacin': 'Resistant', 'Amikacin_g': 'None',
    'Kanamycin': 'Resistant', 'Kanamycin_g': 'None',
    'Capreomycin': 'Resistant', 'Capreomycin_g': 'None',
}
for mutation, antibiotic in resistances.items():
    if antibiotic in genes:
        genes[antibiotic] = 'Susceptible'
        genes[antibiotic + '_g'] = mutation
    elif mutation == 'Lineage':
        genes['Lineage'] = antibiotic

context = patient_info.copy()
context.update(genes)

for paragraph in doc.paragraphs:
    if '{{' in paragraph.text and '}}' in paragraph.text:
        template = Template(paragraph.text)
        paragraph.text = template.render(context)

for table in doc.tables:
    for row in table.rows:
        for cell in row.cells:
            if '{{' in cell.text and '}}' in cell.text:
                template = Template(cell.text)
                cell.text = template.render(context)

input_docx_path = os.path.join(output_dir, (f'{output_base_name}_report.docx'))

doc.save(input_docx_path)
print(f"Saved DOCX file to: {input_docx_path}")


